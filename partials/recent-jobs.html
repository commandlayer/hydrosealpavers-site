<!-- =========================
     RECENT SEALING JOBS (PARTIAL)
     - Continuous slow scroll LEFT→RIGHT
     - Starts showing 3,4,5
     - Pauses on hover / touch-hold
     - Self-contained: CSS + HTML + JS
========================== -->

<style>
  .marquee{
    border:1px solid var(--line);
    border-radius:18px;
    background:#fff;
    overflow:hidden;
    position:relative;
  }

  .marquee-track{
    display:flex;
    width:max-content;
    gap:18px;
    padding:16px 16px;
    will-change: transform;
    transform: translate3d(0,0,0);
    backface-visibility:hidden;
    touch-action: pan-y;
  }

  .job-card{
    flex:0 0 min(420px, 82vw);
    height:290px;
    border-radius:18px;
    border:1px solid rgba(15,110,168,.18);
    background: linear-gradient(135deg, rgba(15,110,168,.18), rgba(57,191,234,.14));
    position:relative;
    overflow:hidden;
  }

  .job-meta{
    position:absolute;
    left:14px;
    right:14px;
    bottom:12px;
    display:flex;
    justify-content:space-between;
    gap:12px;
    align-items:flex-end;
    color:#fff;
    text-shadow:0 10px 22px rgba(0,0,0,.35);
  }

  .job-title{
    font-weight:1000;
    letter-spacing:-.01em;
    line-height:1.1;
  }

  .job-sub{
    font-size:13px;
    opacity:.9;
    margin-top:4px;
    font-weight:700;
  }

  .job-tag{
    font-size:12px;
    font-weight:900;
    padding:7px 10px;
    border-radius:999px;
    background: rgba(255,255,255,.14);
    border:1px solid rgba(255,255,255,.22);
    white-space:nowrap;
  }

  .job-card:hover{
    transform: translateY(-2px);
    transition: transform .18s ease;
  }

 @media (prefers-reduced-motion: reduce){
  /* Don’t force transform:none !important (it prevents JS animation) */
  .marquee-track{
    will-change: auto;
  }
}

</style>

<section class="section" id="recent-jobs">
  <div class="container">
    <h2 class="section-title">Recent Sealing Jobs</h2>

    <div class="marquee" aria-label="Recent jobs marquee">
      <div class="marquee-track" data-recent-jobs-track>
        <!-- EXACTLY 1..5 (edit these later to real jobs/images) -->
        <div class="job-card" data-job><div class="job-meta"><div><div class="job-title">1) Driveway Refresh</div><div class="job-sub">Nocatee • Color-Enhanced</div></div><div class="job-tag">Before/After</div></div></div>
        <div class="job-card" data-job><div class="job-meta"><div><div class="job-title">2) Pool Deck Seal</div><div class="job-sub">Ponte Vedra • Natural</div></div><div class="job-tag">Non-Slip Add-On</div></div></div>
        <div class="job-card" data-job><div class="job-meta"><div><div class="job-title">3) Patio Restore</div><div class="job-sub">Julington Creek</div></div><div class="job-tag">Re-Sand</div></div></div>
        <div class="job-card" data-job><div class="job-meta"><div><div class="job-title">4) Driveway Cleanup</div><div class="job-sub">Mandarin</div></div><div class="job-tag">Deep Clean</div></div></div>
        <div class="job-card" data-job><div class="job-meta"><div><div class="job-title">5) Walkway + Entry</div><div class="job-sub">St. Johns • 210</div></div><div class="job-tag">Sealed</div></div></div>
      </div>
    </div>
  </div>
</section>

<script>
(function(){
  const scope = document.getElementById('recent-jobs') || document;
  const track = scope.querySelector('[data-recent-jobs-track]');
  if(!track) return;

  const marquee = track.closest('.marquee');
  const SPEED = 26; // px/sec

  let running = true;
  let x = 0;
  let loopWidth = 0;
  let last = performance.now();
  let started = false;

  function getGapPx(){
    const st = getComputedStyle(track);
    const gap = parseFloat(st.gap || st.columnGap || "0");
    return isNaN(gap) ? 0 : gap;
  }

  function originals(){
    return Array.from(track.querySelectorAll('[data-job]')).filter(el => !el.matches('[data-clone="1"]'));
  }

  function buildClones(){
    track.querySelectorAll('[data-clone="1"]').forEach(n => n.remove());
    originals().forEach(el => {
      const c = el.cloneNode(true);
      c.setAttribute('data-clone','1');
      track.appendChild(c);
    });
  }

  function measure(){
    const items = originals();
    const gap = getGapPx();

    loopWidth = items.reduce((sum, el, i) => {
      const w = el.getBoundingClientRect().width;
      return sum + w + (i === items.length - 1 ? 0 : gap);
    }, 0);

    if(loopWidth > 0){
      x = ((x % loopWidth) + loopWidth) % loopWidth;
      return true;
    }
    return false;
  }

  function render(){
    if(loopWidth <= 0) return;
    track.style.transform = `translate3d(${x - loopWidth}px,0,0)`;
  }

  function setStartAt3(){
    const items = originals();
    if(items.length < 3) return;

    const gap = getGapPx();
    const w1 = items[0].getBoundingClientRect().width;
    const w2 = items[1].getBoundingClientRect().width;

    x = (w1 + gap) + (w2 + gap);
    if(loopWidth > 0) x = ((x % loopWidth) + loopWidth) % loopWidth;
    render();
  }

  // Keep trying until layout is real (mobile fix)
  function ensureReady(){
    // rebuild once (safe)
    buildClones();

    // try a few times across frames (fonts/layout/mobile)
    let tries = 0;
    function attempt(){
      tries++;
      const ok = measure();
      if(ok){
        setStartAt3();
        render();
        return;
      }
      if(tries < 30) requestAnimationFrame(attempt);
    }
    requestAnimationFrame(attempt);
  }

  function tick(now){
    const dt = (now - last) / 1000;
    last = now;

    // If mobile gave us 0 widths at first, keep recovering
    if(loopWidth <= 0){
      if(!started){
        started = true;
        ensureReady();
      }
      requestAnimationFrame(tick);
      return;
    }

    if(running){
      x += SPEED * dt;
      if(x >= loopWidth) x -= loopWidth;
      render();
    }

    requestAnimationFrame(tick);
  }

  function stop(){ running = false; }
  function start(){ running = true; }

  // Init
  ensureReady();
  requestAnimationFrame(tick);

  // Desktop hover pause
  marquee.addEventListener('mouseenter', stop);
  marquee.addEventListener('mouseleave', start);

  // Mobile: pause only on hold
  let holdTimer = null;
  let holding = false;
  function clearHold(){ if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; } }

  marquee.addEventListener('touchstart', () => {
    clearHold(); holding = false;
    holdTimer = setTimeout(() => { holding = true; stop(); }, 180);
  }, {passive:true});

  marquee.addEventListener('touchmove', () => { clearHold(); }, {passive:true});

  marquee.addEventListener('touchend', () => {
    clearHold();
    if(holding) start();
    holding = false;
  }, {passive:true});

  marquee.addEventListener('touchcancel', () => {
    clearHold();
    if(holding) start();
    holding = false;
  }, {passive:true});

  // Auto re-measure when layout changes (mobile rotation, font swap, etc.)
  const ro = new ResizeObserver(() => {
    const had = loopWidth;
    if(measure()){
      if(!had) setStartAt3();
      render();
    }
  });
  ro.observe(marquee);

  window.addEventListener('orientationchange', () => setTimeout(() => { measure(); setStartAt3(); render(); }, 200));
})();
</script>
